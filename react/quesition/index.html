<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React——面试题 | Anji博客</title>
    <meta name="description" content="Welcome to my blog ">
    
    
    <link rel="preload" href="/assets/css/0.styles.f2124281.css" as="style"><link rel="preload" href="/assets/js/app.d2db35b1.js" as="script"><link rel="preload" href="/assets/js/2.3d65a9bd.js" as="script"><link rel="preload" href="/assets/js/9.6b6163c2.js" as="script"><link rel="prefetch" href="/assets/js/10.7e1a2abf.js"><link rel="prefetch" href="/assets/js/11.b67926d6.js"><link rel="prefetch" href="/assets/js/12.1acbb188.js"><link rel="prefetch" href="/assets/js/13.3042c592.js"><link rel="prefetch" href="/assets/js/14.35ddf8b9.js"><link rel="prefetch" href="/assets/js/15.4d8585d4.js"><link rel="prefetch" href="/assets/js/16.976ac738.js"><link rel="prefetch" href="/assets/js/17.403f7719.js"><link rel="prefetch" href="/assets/js/18.92c074ba.js"><link rel="prefetch" href="/assets/js/19.979680c0.js"><link rel="prefetch" href="/assets/js/20.12c24125.js"><link rel="prefetch" href="/assets/js/21.75236644.js"><link rel="prefetch" href="/assets/js/22.99db2e15.js"><link rel="prefetch" href="/assets/js/23.b5999731.js"><link rel="prefetch" href="/assets/js/24.0d1a4624.js"><link rel="prefetch" href="/assets/js/25.1524be97.js"><link rel="prefetch" href="/assets/js/26.f9d1c2bf.js"><link rel="prefetch" href="/assets/js/27.13235d74.js"><link rel="prefetch" href="/assets/js/28.8e5be585.js"><link rel="prefetch" href="/assets/js/29.49595657.js"><link rel="prefetch" href="/assets/js/3.24073063.js"><link rel="prefetch" href="/assets/js/30.01cb4de1.js"><link rel="prefetch" href="/assets/js/4.57ba7ae3.js"><link rel="prefetch" href="/assets/js/5.838622a9.js"><link rel="prefetch" href="/assets/js/6.7222ed7b.js"><link rel="prefetch" href="/assets/js/7.918a646b.js"><link rel="prefetch" href="/assets/js/8.564e1d40.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f2124281.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Anji博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>入门</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ajax</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>jQuery</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/React/base/" class="sidebar-link">React</a></li><li><a href="/React/psr/" class="sidebar-link">React——三大特性</a></li><li><a href="/React/life/" class="sidebar-link">React——生命周期</a></li><li><a href="/React/reduxbase/" class="sidebar-link">Redux</a></li><li><a href="/React/store/" class="sidebar-link">Redux——Store</a></li><li><a href="/React/action/" class="sidebar-link">Redux-Action</a></li><li><a href="/React/reducer/" class="sidebar-link">Redux-Reducer</a></li><li><a href="/React/asaction/" class="sidebar-link">Redux-异步Action</a></li><li><a href="/React/quesition/" class="active sidebar-link">React——面试题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><strong>1. angularJs 和 react 区别</strong></p> <p>React 对比 Angular 是思想上的转变，它也并不是一个库，是一种开发理念，组件化，分治的管理，数据与 view 的一体化。它只有一个中心,发出状态，渲染 view，对于虚拟 dom 它并没有提高渲染页面的性能，它提供更多的是利用 jsx 便捷生成 dom 元素，利用组件概念进行分治管理页面每个部分(例如 header section footer slider)</p> <p><strong>2. 介绍一下 react</strong></p> <p>React 是一个用于构建用户界面的 JAVASCRIPT 库。React 主要用于构建 UI，很多人认为 React 是 MVC 中的 V（视图）
React 特点有：</p> <p>1.声明式设计 −React 采用声明范式，可以轻松描述应用。</p> <p>2.高效 −React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。</p> <p>3.灵活 −React 可以与已知的库或框架很好地配合。</p> <p>4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。</p> <p>5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</p> <p>6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</p> <p><strong>3. React 单项数据流</strong></p> <p>在 React 中，数据是单向流动的，是从上向下的方向，即从父组件到子组件的方向。</p> <p>state 和 props 是其中重要的概念，如果顶层组件初始化 props，那么 React 会向下遍历整颗组件树，重新渲染相关的子组件。其中 state 表示的是每个组件中内部的的状态，这些状态只在组件内部改变。</p> <p>把组件看成是一个函数，那么他接受 props 作为参数，内部由 state 作为函数的内部参数，返回一个虚拟 dom 的实现。</p> <p><strong>4. react 生命周期函数和 react 组件的生命周期</strong></p> <p>React 的组件在第一次挂在的时候首先获取父组件传递的 props，接着获取初始的 state 值，接着经历挂载阶段的三个生命周期函数，也就是 ComponentWillMount，render，ComponentDidMount，这三个函数分别代表组件将会挂载，组件渲染，组件挂载完毕三个阶段，在组件挂载完成后，组件的 props 和 state 的任意改变都会导致组建进入更新状态，在组件更新阶段，如果是 props 改变，则进入 ComponentWillReceiveProps 函数，接着进入 ComponentShouldUpdate 进行判断是否需要更新，如果是 state 改变则直接进入 ComponentShouldUpdate 判定，这个默认是 true，当判定不需要更新的话，组件继续运行，需要更新的话则依次进入 ComponentWillMount，render，ComponentDidMount 三个函数，当组件卸载时，会首先进入生命周期函数 ComponentWillUnmount,之后才进行卸载，如图</p> <p><img src="/assets/img/be6d285845e3defd.c15ad8e9.png" alt="An image"></p> <p>React 的生命周期函数：</p> <p>初始化阶段：getDefaultProps 获取实例的默认属性，getInitialState 获取每个实例的初始化状态，</p> <p>ComponentWillMount：组件将被装载，渲染到页面上，</p> <p>render：组件在这里生成虚拟的 DOM 节点，</p> <p>ComponentDidMount:组件真正被装载之后</p> <p>运行中状态：</p> <p>componentWillReceiveProps:组件将要接收到属性的时候调用</p> <p>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</p> <p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p> <p>componentWillUpdate:组件即将更新不能修改属性和状态</p> <p>render:组件重新描绘</p> <p>componentDidUpdate:组件已经更新 销毁阶段：</p> <p>componentWillUnmount:组件即将销毁</p> <p><strong>5. reactJs 的组件交流</strong></p> <p>1、父组件向子组件传值:主要是利用 props 来进行交流</p> <p>2、子组件向父组件传值：子组件通过控制自己的 state 然后告诉父组件的点击状态。然后在父组件中展示出来，如图：</p> <p>3、没有任何嵌套关系的组件之间传值：如果组件之间没有任何关系，组件嵌套层次比较深（个人认为 2 层以上已经算深了），或者你为了一些组件能够订阅、写入一些信号，不想让组件之间插入一个组件，让两个组件处于独立的关系。对于事件系统，这里有 2 个基本操作步骤：订阅（subscribe）/监听（listen）一个事件通知，并发送（send）/触发（trigger）/发布（publish）/发送（dispatch）一个事件通知那些想要的组件。</p> <p><strong>6. 有了解过 react 的虚拟 DOM 吗，虚拟 DOM 是怎么对比的呢</strong></p> <p>当然是使用的 diff 算法，diff 算法有三种优化形式：</p> <p>tree diff：将新旧两颗 DOM 树按照层级遍历，只对同级的 DOM 节点进行比较，即同一父节点下的所有子节点，当发现节点已经不存在，则该节点及其子节点会被完全删除，不会进一步比较</p> <p>component diff：不同组件之间的对比，如果组件类型相同，暂不更新，否则删除旧的组件，再创建一个新的组件，插入到删除组件的位置</p> <p>element diff:在类型相同的组件内，再继续对比组件内部的元素</p> <p><strong>7. 项目里用到了 react，为什么要选择 react，react 有哪些好处</strong></p> <p>（1）声明式设计</p> <p>（2）高效：通过对 DOM 的模拟，最大限度的减少与 DOM 的交互。</p> <p>（3）灵活：可以与已知的框架或库很好的配合。</p> <p>（4）JSX：是 js 语法的扩展，不一定使用，但建议用。</p> <p>（5）组件：构建组件，使代码更容易得到复用，能够很好地应用在大项目的开发中。</p> <p>（6）单向响应的数据流：React 实现了单向响应的数据流，从而减少了重复代码，这也是解释了它为什么比传统数据绑定更简单。</p> <p><strong>8. react 的生命周期函数</strong></p> <p><strong>初始化</strong></p> <p>1、getDefaultProps() 设置默认的 props，也可以用 dufaultProps 设置组件的默认属性.</p> <p>2、getInitialState() 在使用 es6 的 class 语法时是没有这个钩子函数的，可以直接在 constructor 中定义 this.state。此时可以访问 this.props</p> <p>3、componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改 state。</p> <p>4、 render() react 最重要的步骤，创建虚拟 dom，进行 diff 算法，更新 dom 树都在此进行。此时就不能更改 state 了。</p> <p>5、componentDidMount() 组件渲染之后调用，只调用一次。</p> <p><strong>更新</strong></p> <p>6、componentWillReceiveProps(nextProps) 组件初始化时不调用，组件接受新的 props 时调用。</p> <p>7、shouldComponentUpdate(nextProps, nextState) react 性能优化非常重要的一环。组件接受新的 state 或者 props 时调用，我们可以设置在此对比前后两个 props 和 state 是否相同，如果相同则返回 false 阻止更新，因为相同的属性状态一定会生成相同的 dom 树，这样就不需要创造新的 dom 树和旧的 dom 树进行 diff 算法对比，节省大量性能，尤其是在 dom 结构复杂的时候</p> <p>8、componentWillUpdata(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改 state</p> <p>9、render() 组件渲染</p> <p>10、componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取 dom 节点。
卸载</p> <p>11、componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。</p> <p><strong>9. react 高阶组件知道吗？</strong></p> <p>高阶组件接收 React 组件作为参数，并且返回一个新的 React 组件。高阶组件本质上也是一个函数，并不是一个组件。</p> <p><strong>10. 说说自己理解的 react</strong></p> <p>React 是用于构建用户界面的 JavaScript 库。React 可以创建交互式 UI。为应用程序中的每个状态建立的视图，并且 React 将在数据更改时进行更新，呈现正确的组件。另外，我们也可以构建管理自己状态的封装组件，然后将它们组合成复杂的 UI。因为组件用 JS 编写而不是模板，所以可以通过应用传递数据，并使状态与 DOM 分离</p> <p><strong>11.react 的组件是通过什么去判断是否刷新的</strong></p> <p>通过 state 是否改变</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/React/asaction/" class="prev">
          Redux-异步Action
        </a></span> <span class="next"><a href="/vue/MVVM/">
          MVVM框架模式
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d2db35b1.js" defer></script><script src="/assets/js/2.3d65a9bd.js" defer></script><script src="/assets/js/9.6b6163c2.js" defer></script>
  </body>
</html>
