(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{190:function(t,e,p){t.exports=p.p+"assets/img/be6d285845e3defd.c15ad8e9.png"},215:function(t,e,p){"use strict";p.r(e);var v=p(0),o=Object(v.a)({},function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[v("strong",[t._v("1. angularJs 和 react 区别")])]),t._v(" "),v("p",[t._v("React 对比 Angular 是思想上的转变，它也并不是一个库，是一种开发理念，组件化，分治的管理，数据与 view 的一体化。它只有一个中心,发出状态，渲染 view，对于虚拟 dom 它并没有提高渲染页面的性能，它提供更多的是利用 jsx 便捷生成 dom 元素，利用组件概念进行分治管理页面每个部分(例如 header section footer slider)")]),t._v(" "),v("p",[v("strong",[t._v("2. 介绍一下 react")])]),t._v(" "),v("p",[t._v("React 是一个用于构建用户界面的 JAVASCRIPT 库。React 主要用于构建 UI，很多人认为 React 是 MVC 中的 V（视图）\nReact 特点有：")]),t._v(" "),v("p",[t._v("1.声明式设计 −React 采用声明范式，可以轻松描述应用。")]),t._v(" "),v("p",[t._v("2.高效 −React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。")]),t._v(" "),v("p",[t._v("3.灵活 −React 可以与已知的库或框架很好地配合。")]),t._v(" "),v("p",[t._v("4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。")]),t._v(" "),v("p",[t._v("5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。")]),t._v(" "),v("p",[t._v("6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。")]),t._v(" "),v("p",[v("strong",[t._v("3. React 单项数据流")])]),t._v(" "),v("p",[t._v("在 React 中，数据是单向流动的，是从上向下的方向，即从父组件到子组件的方向。")]),t._v(" "),v("p",[t._v("state 和 props 是其中重要的概念，如果顶层组件初始化 props，那么 React 会向下遍历整颗组件树，重新渲染相关的子组件。其中 state 表示的是每个组件中内部的的状态，这些状态只在组件内部改变。")]),t._v(" "),v("p",[t._v("把组件看成是一个函数，那么他接受 props 作为参数，内部由 state 作为函数的内部参数，返回一个虚拟 dom 的实现。")]),t._v(" "),v("p",[v("strong",[t._v("4. react 生命周期函数和 react 组件的生命周期")])]),t._v(" "),v("p",[t._v("React 的组件在第一次挂在的时候首先获取父组件传递的 props，接着获取初始的 state 值，接着经历挂载阶段的三个生命周期函数，也就是 ComponentWillMount，render，ComponentDidMount，这三个函数分别代表组件将会挂载，组件渲染，组件挂载完毕三个阶段，在组件挂载完成后，组件的 props 和 state 的任意改变都会导致组建进入更新状态，在组件更新阶段，如果是 props 改变，则进入 ComponentWillReceiveProps 函数，接着进入 ComponentShouldUpdate 进行判断是否需要更新，如果是 state 改变则直接进入 ComponentShouldUpdate 判定，这个默认是 true，当判定不需要更新的话，组件继续运行，需要更新的话则依次进入 ComponentWillMount，render，ComponentDidMount 三个函数，当组件卸载时，会首先进入生命周期函数 ComponentWillUnmount,之后才进行卸载，如图")]),t._v(" "),v("p",[v("img",{attrs:{src:p(190),alt:"An image"}})]),t._v(" "),v("p",[t._v("React 的生命周期函数：")]),t._v(" "),v("p",[t._v("初始化阶段：getDefaultProps 获取实例的默认属性，getInitialState 获取每个实例的初始化状态，")]),t._v(" "),v("p",[t._v("ComponentWillMount：组件将被装载，渲染到页面上，")]),t._v(" "),v("p",[t._v("render：组件在这里生成虚拟的 DOM 节点，")]),t._v(" "),v("p",[t._v("ComponentDidMount:组件真正被装载之后")]),t._v(" "),v("p",[t._v("运行中状态：")]),t._v(" "),v("p",[t._v("componentWillReceiveProps:组件将要接收到属性的时候调用")]),t._v(" "),v("p",[t._v("shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）")]),t._v(" "),v("p",[t._v("shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。")]),t._v(" "),v("p",[t._v("componentWillUpdate:组件即将更新不能修改属性和状态")]),t._v(" "),v("p",[t._v("render:组件重新描绘")]),t._v(" "),v("p",[t._v("componentDidUpdate:组件已经更新 销毁阶段：")]),t._v(" "),v("p",[t._v("componentWillUnmount:组件即将销毁")]),t._v(" "),v("p",[v("strong",[t._v("5. reactJs 的组件交流")])]),t._v(" "),v("p",[t._v("1、父组件向子组件传值:主要是利用 props 来进行交流")]),t._v(" "),v("p",[t._v("2、子组件向父组件传值：子组件通过控制自己的 state 然后告诉父组件的点击状态。然后在父组件中展示出来，如图：")]),t._v(" "),v("p",[t._v("3、没有任何嵌套关系的组件之间传值：如果组件之间没有任何关系，组件嵌套层次比较深（个人认为 2 层以上已经算深了），或者你为了一些组件能够订阅、写入一些信号，不想让组件之间插入一个组件，让两个组件处于独立的关系。对于事件系统，这里有 2 个基本操作步骤：订阅（subscribe）/监听（listen）一个事件通知，并发送（send）/触发（trigger）/发布（publish）/发送（dispatch）一个事件通知那些想要的组件。")]),t._v(" "),v("p",[v("strong",[t._v("6. 有了解过 react 的虚拟 DOM 吗，虚拟 DOM 是怎么对比的呢")])]),t._v(" "),v("p",[t._v("当然是使用的 diff 算法，diff 算法有三种优化形式：")]),t._v(" "),v("p",[t._v("tree diff：将新旧两颗 DOM 树按照层级遍历，只对同级的 DOM 节点进行比较，即同一父节点下的所有子节点，当发现节点已经不存在，则该节点及其子节点会被完全删除，不会进一步比较")]),t._v(" "),v("p",[t._v("component diff：不同组件之间的对比，如果组件类型相同，暂不更新，否则删除旧的组件，再创建一个新的组件，插入到删除组件的位置")]),t._v(" "),v("p",[t._v("element diff:在类型相同的组件内，再继续对比组件内部的元素")]),t._v(" "),v("p",[v("strong",[t._v("7. 项目里用到了 react，为什么要选择 react，react 有哪些好处")])]),t._v(" "),v("p",[t._v("（1）声明式设计")]),t._v(" "),v("p",[t._v("（2）高效：通过对 DOM 的模拟，最大限度的减少与 DOM 的交互。")]),t._v(" "),v("p",[t._v("（3）灵活：可以与已知的框架或库很好的配合。")]),t._v(" "),v("p",[t._v("（4）JSX：是 js 语法的扩展，不一定使用，但建议用。")]),t._v(" "),v("p",[t._v("（5）组件：构建组件，使代码更容易得到复用，能够很好地应用在大项目的开发中。")]),t._v(" "),v("p",[t._v("（6）单向响应的数据流：React 实现了单向响应的数据流，从而减少了重复代码，这也是解释了它为什么比传统数据绑定更简单。")]),t._v(" "),v("p",[v("strong",[t._v("8. react 的生命周期函数")])]),t._v(" "),v("p",[v("strong",[t._v("初始化")])]),t._v(" "),v("p",[t._v("1、getDefaultProps() 设置默认的 props，也可以用 dufaultProps 设置组件的默认属性.")]),t._v(" "),v("p",[t._v("2、getInitialState() 在使用 es6 的 class 语法时是没有这个钩子函数的，可以直接在 constructor 中定义 this.state。此时可以访问 this.props")]),t._v(" "),v("p",[t._v("3、componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改 state。")]),t._v(" "),v("p",[t._v("4、 render() react 最重要的步骤，创建虚拟 dom，进行 diff 算法，更新 dom 树都在此进行。此时就不能更改 state 了。")]),t._v(" "),v("p",[t._v("5、componentDidMount() 组件渲染之后调用，只调用一次。")]),t._v(" "),v("p",[v("strong",[t._v("更新")])]),t._v(" "),v("p",[t._v("6、componentWillReceiveProps(nextProps) 组件初始化时不调用，组件接受新的 props 时调用。")]),t._v(" "),v("p",[t._v("7、shouldComponentUpdate(nextProps, nextState) react 性能优化非常重要的一环。组件接受新的 state 或者 props 时调用，我们可以设置在此对比前后两个 props 和 state 是否相同，如果相同则返回 false 阻止更新，因为相同的属性状态一定会生成相同的 dom 树，这样就不需要创造新的 dom 树和旧的 dom 树进行 diff 算法对比，节省大量性能，尤其是在 dom 结构复杂的时候")]),t._v(" "),v("p",[t._v("8、componentWillUpdata(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改 state")]),t._v(" "),v("p",[t._v("9、render() 组件渲染")]),t._v(" "),v("p",[t._v("10、componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取 dom 节点。\n卸载")]),t._v(" "),v("p",[t._v("11、componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。")]),t._v(" "),v("p",[v("strong",[t._v("9. react 高阶组件知道吗？")])]),t._v(" "),v("p",[t._v("高阶组件接收 React 组件作为参数，并且返回一个新的 React 组件。高阶组件本质上也是一个函数，并不是一个组件。")]),t._v(" "),v("p",[v("strong",[t._v("10. 说说自己理解的 react")])]),t._v(" "),v("p",[t._v("React 是用于构建用户界面的 JavaScript 库。React 可以创建交互式 UI。为应用程序中的每个状态建立的视图，并且 React 将在数据更改时进行更新，呈现正确的组件。另外，我们也可以构建管理自己状态的封装组件，然后将它们组合成复杂的 UI。因为组件用 JS 编写而不是模板，所以可以通过应用传递数据，并使状态与 DOM 分离")]),t._v(" "),v("p",[v("strong",[t._v("11.react 的组件是通过什么去判断是否刷新的")])]),t._v(" "),v("p",[t._v("通过 state 是否改变")])])},[],!1,null,null,null);e.default=o.exports}}]);