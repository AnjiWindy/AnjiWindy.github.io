(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{188:function(t,s,a){t.exports=a.p+"assets/img/untitled.a9434cf5.png"},189:function(t,s,a){t.exports=a.p+"assets/img/untitled1.ac8d5dd4.png"},217:function(t,s,a){"use strict";a.r(s);var e=a(0),n=Object(e.a)({},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"vuex-是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex-是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("Vuex 是什么？")])]),t._v(" "),e("p",[t._v("1.借鉴 了 Flux、Redux、The Elm Architecture 。")]),t._v(" "),e("p",[t._v("2.Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。")]),t._v(" "),e("p",[t._v("3.它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。")]),t._v(" "),e("p",[t._v("4.Vuex 也集成到 Vue 的官方调试工具。")]),t._v(" "),e("p",[t._v("5.一个 Vuex 应用的核心是 store（仓库，一个容器），store 包含着你的应用中大部分的状态(state)。")]),t._v(" "),e("h3",{attrs:{id:"基础的使用步骤："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础的使用步骤：","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("基础的使用步骤")]),t._v("：")]),t._v(" "),e("p",[t._v("1、下载安装：npm install vuex --save")]),t._v(" "),e("p",[t._v("2、创建一个存储数据的仓库，为了方便管理我们可以在 src 目录下创建一个 store 目录，然后在里面创建数据仓库文件 index.js")]),t._v(" "),e("p",[t._v("3、我们需要将该数据仓库 import 到 main.js 中使关键字“"),e("strong",[t._v("store")]),t._v("”成为全局能使用的 API")]),t._v(" "),e("p",[t._v("4、由于我们在 main.js 将 store 加载到了 new Vue 实例中，因此我们要在组件中调用数据仓库中存储的数据")]),t._v(" "),e("h3",{attrs:{id:"数据流向图："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据流向图：","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("数据流向图：")])]),t._v(" "),e("p",[e("img",{attrs:{src:a(188),alt:"An image"}})]),t._v(" "),e("h3",{attrs:{id:"vuex-store-实例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex-store-实例","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("vuex store 实例")])]),t._v(" "),e("p",[t._v("每一个 Vuex 应用的核心就是 store（仓库），这里存放了应用中的大部分状态 stage，操作状态的 mutations，触发 mutations 的 actions。")]),t._v(" "),e("h3",{attrs:{id:"store-实例的生成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#store-实例的生成","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("store 实例的生成")])]),t._v(" "),e("p",[t._v("与生成 vue 实例一样，同样是调用一个构造函数 Vuex.Store,并传入一个 option 对象，从而生成一个 store 实例。这个实例包含了应用的状态，和改变应用状态的方法。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(189),alt:"An image"}})]),t._v(" "),e("p",[e("strong",[t._v("但是 store 实例尽管提供了改变状态的方法，它本身是不改变状态的。改变状态的源头来自组件和生命周期的钩子函数。 在组件中，使用计算属性来读取应用的状态，通过 action——>mutation——>state 来改变应用的 state。另外，并不是说应用的所有状态都应该放到 vuex 的 state 中，state 主要放用于共享的，或者应用级别的状态")])]),t._v(" "),e("p",[e("strong",[t._v("1、State")])]),t._v(" "),e("p",[t._v("vuex 中的数据源，我们需要保存的数据就保存在这里，可以在页面通过 this.$store.state 来获取我们定义的数据")]),t._v(" "),e("p",[e("strong",[t._v("2.Getters")])]),t._v(" "),e("p",[t._v("Getter 相当于 vue 中的 computed 计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算，这里我们可以通过定义 vuex 的 Getter 来获取，Getters 可以用于监听、state 中的值的变化，返回计算后的结果")]),t._v(" "),e("p",[e("strong",[t._v("3.Mutations")])]),t._v(" "),e("p",[t._v("如果需要修改 store 中的值唯一的方法就是提交 mutation 来修改")]),t._v(" "),e("p",[e("strong",[t._v("4.Actions")])]),t._v(" "),e("p",[t._v("官方并不建议我们这样直接去修改 store 里面的值，而是让我们去提交一个 actions，在 actions 中提交 mutation 再去修改状态值")]),t._v(" "),e("h3",{attrs:{id:"vuex-的使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex-的使用场景","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("vuex 的使用场景")])]),t._v(" "),e("p",[t._v("1.不适用：小型简单应用，用 Vuex 是繁琐冗余的，更适合使用简单的 store 模式。")]),t._v(" "),e("p",[t._v("2. 适用于：中大型单页应用，你可能会考虑如何把组件的共享状态抽取出来，以一个全局单例模式管理，不管在哪个组件，都能获取状态/触发行为，解决问题如下：")]),t._v(" "),e("p",[t._v("① 多个视图使用于同一状态：")]),t._v(" "),e("p",[t._v("传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力")]),t._v(" "),e("p",[t._v("② 不同视图需要变更同一状态：")]),t._v(" "),e("p",[t._v("采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝，通常会导致无法维护的代码")]),t._v(" "),e("h3",{attrs:{id:"辅助函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#辅助函数","aria-hidden":"true"}},[t._v("#")]),t._v(" 辅助函数")]),t._v(" "),e("h4",{attrs:{id:"mapstate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mapstate","aria-hidden":"true"}},[t._v("#")]),t._v(" mapState")]),t._v(" "),e("p",[t._v("引入")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" mapState "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" 'vuex\n")])])]),e("p",[t._v("3 种用法")]),t._v(" "),e("p",[t._v("---对象")]),t._v(" "),e("p",[t._v("如果使用箭头函数，当 vuex 的 state 和当前组件的 state，含有相同的变量名称时，this 获取的是 vuex 中的变量，而不是局部变量")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("computed"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("mapState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 箭头函数 count: state => state.count,")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里为了能够使用this获取局部变量localCount，必须使用常规函数 countPlusLocalState (state) {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("localCount\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("---数组\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("computed"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("mapState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 映射 this.count 为 store.state.count 'count'])")]),t._v("\n")])])]),e("p",[t._v("---对象展开运算符\nmapState 函数返回的是一个对象。如果需要将它与局部计算属性混合使用，通常我们需要一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("computed"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("localComputed")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("mapState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n也可以使用"),e("span",{pre:!0,attrs:{class:"token template-string"}},[e("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("...mapState([])")]),e("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("但前提是映射的计算属性的名称与state的子节点名称相同，如果state在vuex的modules中，则不成功。\n")])])]),e("h4",{attrs:{id:"mapgetters"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mapgetters","aria-hidden":"true"}},[t._v("#")]),t._v(" mapGetters")]),t._v(" "),e("p",[t._v("mapGetters 将 store 中的 getter 映射到局部计算属性")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("computed"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("mapGetters")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'oneGetter'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'anotherGetter'")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h4",{attrs:{id:"mapmutations"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mapmutations","aria-hidden":"true"}},[t._v("#")]),t._v(" mapMutations")]),t._v(" "),e("p",[t._v("使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用。")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("methods"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将this.tips映射成 this.$store.commit('tips')")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("mapMutations")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'tips'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h4",{attrs:{id:"mapaction"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mapaction","aria-hidden":"true"}},[t._v("#")]),t._v(" mapAction")]),t._v(" "),e("p",[t._v("使用 mapActions 辅助函数将组件的 methods 映射成 store.dispatch 调用")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("methods"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将this.tips映射成 this.$store.dispatch('tips')")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("mapActions")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'tips'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])},[],!1,null,null,null);s.default=n.exports}}]);