(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{184:function(t,n,e){t.exports=e.p+"assets/img/38ae28b2150cb6a3.44df29ad.png"},225:function(t,n,e){"use strict";e.r(n);var o=e(0),p=Object(o.a)({},function(){var t=this,n=t.$createElement,o=t._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("p",[o("img",{attrs:{src:e(184),alt:"An image"}})]),t._v(" "),o("p",[o("strong",[t._v("生命周期的方法有：")])]),t._v(" "),o("ul",[o("li",[o("p",[o("strong",[t._v("componentWillMount")]),t._v(" 在渲染前调用,在客户端也在服务端。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("componentDidMount")]),t._v(" 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的 DOM 结构，可以通过 this.getDOMNode()来进行访问。如果你想和其他 JavaScript 框架一起使用，可以在这个方法中调用 setTimeout, setInterval 或者发送 AJAX 请求等操作(防止异步操作阻塞 UI)。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("componentWillReceiveProps")]),t._v(" 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化 render 时不会被调用。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("shouldComponentUpdate")]),t._v(" 返回一个布尔值。在组件接收到新的 props 或者 state 时被调用。在初始化时或者使用 forceUpdate 时不被调用。\n可以在你确认不需要更新组件时使用。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("componentWillUpdate")]),t._v(" 在组件接收到新的 props 或者 state 但还没有 render 时被调用。在初始化时不会被调用。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("componentDidUpdate")]),t._v(" 在组件完成更新后立即调用。在初始化时不会被调用。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("componentWillUnmount")]),t._v(" 在组件从 DOM 中移除之前立刻被调用。")])])])])},[],!1,null,null,null);n.default=p.exports}}]);